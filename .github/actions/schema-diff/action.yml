name: Aggregate Schema Diff Report

on:
  workflow_dispatch:
    inputs:
      config_path:
        description: "Path to repos config (YAML)"
        default: ".github/schema-repos.yml"
        required: true
      tag_selector:
        description: "Tag selection: auto | latest | pattern:<regex>"
        default: "auto"
        required: true

permissions:
  contents: read
  actions: write

jobs:
  build-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
    steps:
      - name: Checkout central repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: mk
        name: Build matrix from config
        uses: actions/github-script@v7
        with:
          # Можешь передать путь явно (иначе возьмётся из workflow_dispatch или дефолт)
          config_path: ${{ github.event.inputs.config_path }}
          script: |
            const fs = require('fs');

            // 1) попытаемся взять путь, переданный в 'with'
            const inputCfg = core.getInput('config_path'); // может быть '' если не передан
            // 2) попытаемся прочитать из workflow_dispatch (через GITHUB_EVENT_PATH)
            let dispatchCfg = '';
            try {
              const eventPath = process.env.GITHUB_EVENT_PATH;
              if (eventPath && fs.existsSync(eventPath)) {
                const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));
                if (event && event.inputs && typeof event.inputs.config_path === 'string') {
                  dispatchCfg = event.inputs.config_path;
                }
              }
            } catch (e) {
              core.warning(`Failed to read GITHUB_EVENT_PATH: ${e.message}`);
            }
            // 3) дефолт
            const fallbackCfg = '.github/schema-repos.yml';

            const candidates = [inputCfg, dispatchCfg, fallbackCfg].map(s => (s || '').trim());
            const cfgPath = candidates.find(s => s.length > 0) || fallbackCfg;

            core.info(`Config path resolved to: ${cfgPath}`);

            if (!fs.existsSync(cfgPath)) {
              core.setFailed(`Config file not found at: ${cfgPath}. Make sure it exists in the checked-out repo.`);
              return;
            }

            const raw = fs.readFileSync(cfgPath, 'utf8');

            // --- Простой парсер нашего формата YAML ---
            // Ожидается структура:
            // repos:
            //   - name: khandramai/a
            //     paths: ["ramlsa"]
            //   - name: khandramai/b
            //     paths:
            //       - ramlsb
            const repos = [];
            const lines = raw.split(/\r?\n/);
            let i = 0;
            while (i < lines.length && !/^repos:/.test(lines[i].trim())) i++;
            i++;

            let cur = null;
            for (; i < lines.length; i++) {
              const l = lines[i];

              // Новая запись репозитория
              const mName = l.match(/^\s*-\s*name:\s*(.+)\s*$/);
              if (mName) {
                if (cur) repos.push(cur);
                cur = { name: mName[1].trim(), paths: [] };
                continue;
              }

              // Инлайн массив путей: paths: ["a","b"]
              const mInline = l.match(/^\s*paths:\s*\[(.+)\]\s*$/);
              if (mInline && cur) {
                cur.paths = mInline[1]
                  .split(',')
                  .map(s => s.trim().replace(/^['"]|['"]$/g, ''))
                  .filter(Boolean);
                continue;
              }

              // Блочный список путей:
              const mPathsKey = l.match(/^\s*paths:\s*$/);
              if (mPathsKey && cur) {
                let j = i + 1;
                while (j < lines.length && /^\s+-\s+/.test(lines[j])) {
                  const mItem = lines[j].match(/^\s*-\s+(.+)\s*$/);
                  if (mItem) cur.paths.push(mItem[1].trim());
                  j++;
                }
              }
            }
            if (cur) repos.push(cur);

            if (!repos.length) {
              core.setFailed("No repos in config. Expected a top-level 'repos:' list.");
              return;
            }

            // sanity: имя и хотя бы пустой массив путей
            for (const r of repos) {
              if (!r.name || typeof r.name !== 'string') {
                core.setFailed("Invalid config: every repo entry must have 'name'.");
                return;
              }
              if (!Array.isArray(r.paths)) r.paths = [];
            }

            const matrix = { include: repos.map(r => ({ repo: r.name, paths: r.paths })) };
            core.setOutput('matrix', JSON.stringify(matrix));
            core.info(`Matrix built: ${JSON.stringify(matrix)}`);
          result-encoding: string

  per-repo:
    name: Build report for ${{ matrix.repo }}
    needs: build-matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.build-matrix.outputs.matrix) }}
    steps:
      - name: Run schema diff (composite action from repo c)
        id: run
        uses: ./.github/actions/schema-diff
        with:
          repo: ${{ matrix.repo }}
          paths_json: ${{ toJson(matrix.paths) }}
          tag_selector: ${{ github.event.inputs.tag_selector }}

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: "${{ matrix.repo }}-${{ steps.run.outputs.prev_tag }}__${{ steps.run.outputs.curr_tag }}"
          path: ${{ steps.run.outputs.report_dir }}
          if-no-files-found: error

  aggregate:
    name: Aggregate summary
    needs: per-repo
    runs-on: ubuntu-latest
    steps:
      - name: Summary
        run: |
          {
            echo "# Combined Schema Diff Report"
            echo
            echo "Артефакты доступны в разделе **Artifacts**:"
            echo "- Имя: \`<owner/repo>-<prev>__<curr>\` (например, \`khandramai/a-1.2.3__1.2.4\`)"
            echo "- Содержимое: \`README.md\` + сабрепорты (.md) по указанным папкам"
          } >> "$GITHUB_STEP_SUMMARY"
